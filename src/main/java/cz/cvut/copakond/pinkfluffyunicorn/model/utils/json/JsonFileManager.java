package cz.cvut.copakond.pinkfluffyunicorn.model.utils.json;

import java.io.IOException;

import cz.cvut.copakond.pinkfluffyunicorn.Launcher;
import cz.cvut.copakond.pinkfluffyunicorn.model.utils.enums.ErrorMsgsEnum;
import org.json.JSONArray;
import org.json.JSONObject;
import org.json.JSONException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.List;
import java.util.logging.Logger;

public class JsonFileManager {
    private static final Logger logger = Logger.getLogger(JsonFileManager.class.getName());
    
    public static JSONObject readJsonFromFile(String filePath) {
        try {
            String content = new String(Files.readAllBytes(Paths.get(filePath)));
            return new JSONObject(content);
        } catch (IOException e) {
           ErrorMsgsEnum.LOAD_JSON_FILE.getValue(filePath, e);
        } catch (JSONException e) {
            ErrorMsgsEnum.LOAD_JSON_PARSE.getValue(filePath, e);
        }
        return null;
    }

    public static boolean writeJsonToFile(String filePath, JSONObject data) {
        try {
            // Convert the JSONObject to a formatted string with custom list formatting
            String jsonString = formatJson(data, 0);

            // Write the formatted JSON string to the file
            Files.write(Paths.get(filePath), jsonString.getBytes());
            return true;
        } catch (IOException e) {
            ErrorMsgsEnum.SAVE_JSON_FILE.getValue(filePath, e);
        }
        return false;
    }

    // Method to format JSON with custom list formatting, the inner lists are in one line, generated by AI
    private static String formatJson(Object obj, int indent) {
        StringBuilder sb = new StringBuilder();
        String indentStr = "  ".repeat(indent);  // spaces for indentation

        if (obj instanceof JSONObject) {
            JSONObject json = (JSONObject) obj;
            sb.append("{\n");
            int count = 0;
            for (String key : json.keySet()) {
                if (count++ > 0) sb.append(",\n");
                sb.append(indentStr).append("  \"").append(key).append("\": ");
                sb.append(formatJson(json.get(key), indent + 1));
            }
            sb.append("\n").append(indentStr).append("}");
        }
        else if (obj instanceof JSONArray) {
            JSONArray arr = (JSONArray) obj;

            // check if it's a list of lists that should be in one line
            boolean isInnerList = arr.length() > 0 && arr.get(0) instanceof JSONArray;

            if (isInnerList) {
                sb.append("[\n");
                for (int i = 0; i < arr.length(); i++) {
                    if (i > 0) sb.append(",\n");
                    sb.append(indentStr).append("  ").append(arr.get(i).toString());
                }
                sb.append("\n").append(indentStr).append("]");
            } else {
                sb.append(arr.toString());
            }
        }
        else if (obj instanceof String) {
            sb.append("\"").append(obj).append("\"");
        }
        else {
            sb.append(obj);
        }

        return sb.toString();
    }

    public static List<List<Integer>> getProfileLFromJsonFile(String filePath) {
        List<List<Integer>> profileData = List.of(List.of(), List.of());
        JSONObject jsonObject = readJsonFromFile(filePath);

        if (jsonObject != null) {
            JSONArray completedStory = jsonObject.optJSONArray("completedStory");
            JSONArray completedCustom = jsonObject.optJSONArray("completedCustom");

            if (completedStory != null && completedCustom != null) {
                profileData = List.of(
                        completedStory.toList().stream().map(Object::toString).map(Integer::valueOf).sorted().toList(),
                        completedCustom.toList().stream().map(Object::toString).map(Integer::valueOf).sorted().toList()
                );
            }
        }
        return profileData;
    }

    public static boolean saveProfileLToJsonFile(String filePath, List<List<Integer>> data) {
        JSONObject jsonObject = new JSONObject();
        JSONArray completedStory = new JSONArray(data.get(0));
        JSONArray completedCustom = new JSONArray(data.get(1));
        jsonObject.put("completedStory", completedStory);
        jsonObject.put("completedCustom", completedCustom);
        return writeJsonToFile(filePath, jsonObject);
    }

    public static List<Integer> readSettingsFromJson(String filePath) {
        JSONObject jsonObject = readJsonFromFile(filePath);

        if (jsonObject != null) {
            int musicVolume = jsonObject.optInt("music", 50);
            int sfxVolume = jsonObject.optInt("sfx", 50);
            int fps = jsonObject.optInt("fps", 60);
            int fullScreen = jsonObject.optBoolean("fullScreen", false) ? 1 : 0;

            return List.of(musicVolume, sfxVolume, fps, fullScreen);
        }
        return null;
    }

    public static boolean writeSettingsToJson(String filePath, int musicVolume, int sfxVolume, int fps, boolean fullScreen) {
        JSONObject jsonObject = new JSONObject();
        jsonObject.put("music", musicVolume);
        jsonObject.put("sfx", sfxVolume);
        jsonObject.put("fps", fps);
        jsonObject.put("fullScreen", fullScreen);
        return writeJsonToFile(filePath, jsonObject);
    }
}
